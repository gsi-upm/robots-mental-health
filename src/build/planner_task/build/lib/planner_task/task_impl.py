# Copyright (c) 2025 TODO. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import time

from rclpy.action import ActionServer, GoalResponse
from rclpy.lifecycle import Node
from rclpy.lifecycle import State
from rclpy.lifecycle import TransitionCallbackReturn

from ament_index_python.packages import get_package_share_directory

# custom 'control' action for this task. to start/stop it.
# This has been generated by rpk alongside this node.
from task_msgs.action import TaskControl
from ui_msgs.srv import SetUiFragment

from diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus, KeyValue

from chatbot_msgs.srv import GetResponse

class TaskImpl(Node):
    """
    Implementation of task planner_task.

    This is the main class for the task. It is a ROS2 node that uses the
    lifecycle feature of ROS2 to manage its states.

    This template does not implement any specific task, but it is a good
    starting point for creating a new task.

    Don't forget to update accordingly the manifest of the task, included in
    package.xml, to describe what your task is actually doing.
    """

    def __init__(self) -> None:
        """Construct the node."""
        super().__init__('task_planner_task')

        self.get_logger().info("Initialising...")
        self._timer = None
        self._diag_pub = None
        self._diag_timer = None

        self.task_server = None  # action server to start/stop this task

        self.ui_client = None  # service client to set the UI

        self.llm_client = None

        self.last_generated_plan = None  # Almacenará el JSON generado


        #######################################
        #
        # TODO: Add here any other variables
        # that you need in your node
        # Initialisation should happen in the
        # on_configure state.
        #

        self.task_running = False
        self.completed = 0

        self.get_logger().info('Task planner_task started, but not yet configured.')

    def on_request_goal(self, goal_handle):
        """Accept incoming goal if appropriate."""
        if self._state_machine.current_state[1] != "active":
            self.get_logger().error("Task is not active, rejecting goal")
            return GoalResponse.REJECT

        self.get_logger().info("Accepted a new goal")
        return GoalResponse.ACCEPT

    def set_ui_fragment(self, qml_name: str):
        if not self.ui_client.wait_for_service(timeout_sec=3.0):
            self.get_logger().error("No se pudo conectar al servicio de UI.")
            return

    req = SetUiFragment.Request()
    req.qml_import_path = get_package_share_directory("ui_task") + "/res/ui"
    req.qml_fragment = qml_name

    future = self.ui_client.call_async(req)

    def callback(fut):
        result = fut.result()
        if result.error_msg:
            self.get_logger().error(f"Error al cambiar UI: {result.error_msg}")
        else:
            self.get_logger().info("Vista UI cambiada exitosamente.")

    future.add_done_callback(callback)

    def on_request_exec(self, goal_handle):
    self.get_logger().info("Iniciando tarea de planificación")

    # Muestra la vista inicial (PlannerInput, donde se espera que el usuario aporte la info necesaria para crear la planificación)
    self.set_ui_fragment("PlannerInput.qml")

    time.sleep(2)  # Dar tiempo a mostrar la UI

    # Simula entrada de usuario (hardcodeado por ahora)
    user_input = (
        "Tengo un examen de matemáticas el 2025-06-20, dificultad alta. "
        "Trabajo de historia para el 2025-06-18, dificultad media. "
        "Puedo estudiar 2h lunes, 3h martes, 2h miércoles, 4h jueves, 3h viernes, 1h sábado y 1h domingo."
    )

    # Llama al LLM en modo planificación
    request = GetResponse.Request()
    request.user_id = "test_user"
    request.model = "plan"
    request.input = user_input

    if not self.llm_client.wait_for_service(timeout_sec=5.0):
        self.get_logger().error("Servicio de LLM no disponible")
        goal_handle.abort()
        return TaskControl.Result(result="error: llm service")

    future = self.llm_client.call_async(request)

    def on_llm_response(fut):
        try:
            plan_json = json.loads(fut.result().output)
            self.last_generated_plan = plan_json
            self.get_logger().info("Plan generado correctamente")

            # Mostrar en la vista Plan
            self.set_ui_fragment("PlannerView.qml")
            goal_handle.succeed()
        except Exception as e:
            self.get_logger().error(f"Error procesando respuesta del LLM: {e}")
            goal_handle.abort()

    future.add_done_callback(on_llm_response)

    return TaskControl.Result(result="plan completed")


    #################################
    #
    # Lifecycle transitions callbacks
    #
    def on_configure(self, state: State) -> TransitionCallbackReturn:
        """
        Configure the skill.

        You usually want to do the following in this state:
        - Read ROS parameters (if any)
        - Create ROS action clients and servers
        - Create ROS publishers and subscribers
        - Start publishing diagnostic information

        While the task is configured, but not activated, it should not
        perform any actions that are not required for configuration, such as
        effectively processing data or calling external services.
        For instance, incoming goals on an action server should be rejected.

        :return: The state machine either invokes a transition to the
            "inactive" state or stays in "unconfigured" depending on the
            return value.
            TransitionCallbackReturn.SUCCESS transitions to "inactive".
            TransitionCallbackReturn.FAILURE transitions to "unconfigured".
            TransitionCallbackReturn.ERROR or any uncaught exceptions to
            "errorprocessing"
        """
        
        # Crear el cliente llm
        self.llm_client = self.create_client(GetResponse, "/chatbot/get_response")

        # configure and start diagnostics publishing
        self._diag_pub = self.create_publisher(DiagnosticArray, '/diagnostics', 1)
        self._diag_timer = self.create_timer(1., self.publish_diagnostics)

        # create here publishers, subscribers, clients, servers, etc.
        # required to implement the task (if any)

        # create the control server for ourselves
        self.task_server = ActionServer(
            self, TaskControl, "/planner_task/control",
            goal_callback=self.on_request_goal,
            execute_callback=self.on_request_exec)

        self.get_logger().info("Task planner_task is configured, but not yet active")
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state: State) -> TransitionCallbackReturn:
        """
        Activate the skill.

        You usually want to do the following in this state:
        - Create and start any timers performing periodic tasks
        - Start processing data, and accepting action goals, if any

        """
        ui_service = "/ui/set_fragment"
        self.ui_client = self.create_client(SetUiFragment, ui_service)
        ui_ok = self.ui_client.wait_for_service(timeout_sec=1)
        if not ui_ok:
            self.get_logger().error(f"The UI server is not available (service {ui_service}).")

        # As an example, define a timer that fires every second to call the run
        # function
        timer_period = 1  # in sec self._timer =
        self.create_timer(timer_period, self.run)

        self.get_logger().info("Task planner_task is active and running")
        return super().on_activate(state)

    def on_deactivate(self, state: State) -> TransitionCallbackReturn:
        """Stop the timer to stop calling the `run` function (main task of your application)."""
        self.get_logger().info("Stopping task...")
        self.destroy_client(self.ui_client)
        self.destroy_timer(self._timer)

        self.get_logger().info("Task planner_task is stopped (inactive)")
        return super().on_deactivate(state)

    def on_shutdown(self, state: State) -> TransitionCallbackReturn:
        """
        Shutdown the node, after a shutting-down transition is requested.

        :return: The state machine either invokes a transition to the
            "finalized" state or stays in the current state depending on the
            return value.
            TransitionCallbackReturn.SUCCESS transitions to "finalized".
            TransitionCallbackReturn.FAILURE remains in current state.
            TransitionCallbackReturn.ERROR or any uncaught exceptions to
            "errorprocessing"
        """
        self.get_logger().info('Shutting down task planner_task.')
        self.destroy_timer(self._diag_timer)
        self.destroy_publisher(self._diag_pub)

        self.destroy_timer(self._timer)

        self.get_logger().info("Task planner_task finalized.")
        return TransitionCallbackReturn.SUCCESS

    #################################

    def publish_diagnostics(self):

        arr = DiagnosticArray()
        msg = DiagnosticStatus(
            level=DiagnosticStatus.OK,
            name="/task_planner_task",
            message="task planner_task is running",
            values=[
                KeyValue(key="Module name", value="planner_task"),
                KeyValue(key="Current lifecycle state",
                         value=self._state_machine.current_state[1]),
                KeyValue(key="Current task completion percentage",
                         value=f"{self.completed}"),
            ],
        )

        arr.header.stamp = self.get_clock().now().to_msg()
        arr.status = [msg]
        self._diag_pub.publish(arr)

    def run(self) -> None:
        """
        Background task of the activity.

        This function will be triggered by the timer in the class,
        and only when the timer is active.
        """
        #######################################
        #
        # TODO: Implement here any background
        # task required by your task
        # If the task is deactivated,
        # this function is not called anymore
        #

        if self.task_running:
            self.completed += 10
